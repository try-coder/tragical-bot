// index.js - Main Bot Entry Point
require('dotenv').config();
const { default: makeWASocket, useMultiFileAuthState, DisconnectReason, fetchLatestBaileysVersion } = require('@whiskeysockets/baileys');
const Pino = require('pino');
const qrcode = require('qrcode-terminal');
const connectDB = require('./config/database');
const { log } = require('./utils/logger');
const User = require('./models/User');
const Group = require('./models/Group');
const fs = require('fs');

// Connect to MongoDB
connectDB();

async function startBot() {
    log('INFO', 'ğŸš€ Starting TRAGICAL Bot...');
    
    // Get latest version
    const { version, isLatest } = await fetchLatestBaileysVersion();
    log('INFO', `ğŸ“± Using WA v${version.join('.')}, isLatest: ${isLatest}`);

    // Ensure auth folder exists
    const authFolder = process.env.SESSION_FOLDER || 'auth';
    if (!fs.existsSync(authFolder)) {
        fs.mkdirSync(authFolder, { recursive: true });
    }

    const { state, saveCreds } = await useMultiFileAuthState(authFolder);
    
    const sock = makeWASocket({
        version,
        logger: Pino({ level: 'silent' }),
    const sock = makeWASocket({
        version,
        logger: Pino({ level: 'silent' }),
        auth: state,
        browser: ['TRAGICAL', 'Chrome', '3.0.0'],
        syncFullHistory: false,
        generateHighQualityLinkPreview: false,
        shouldSyncHistory: false
    });
        auth: state,
        browser: ['TRAGICAL', 'Chrome', '3.0.0'],
        syncFullHistory: false,
        generateHighQualityLinkPreview: false,
        shouldSyncHistory: false
    });

    // Handle connection updates
    sock.ev.on('connection.update', async (update) => {
        const { connection, qr, lastDisconnect } = update;
        
        // If we get a QR code, display it
        if (qr) {
            console.log('\n' + '='.repeat(60));
            console.log('ğŸ“± TRAGICAL BOT - WhatsApp Authentication Required');
            console.log('='.repeat(60));
            console.log('\nğŸ”¹ SCAN THIS QR CODE WITH YOUR WHATSAPP:\n');
            console.log('1. Open WhatsApp on your phone');
            console.log('2. Tap Menu (3 dots) or Settings');
            console.log('3. Go to "Linked Devices"');
            console.log('4. Tap "Link a Device"');
            console.log('5. Scan this QR code:\n');
            
            // Generate QR code
            qrcode.generate(qr, { small: true });
            
            console.log('\n' + '='.repeat(60));
            console.log('â³ Waiting for scan... (QR expires in 60 seconds)');
            console.log('='.repeat(60) + '\n');
        }
        
        if (connection === 'open') {
            console.clear();
            console.log('\n' + '='.repeat(60));
            log('SUCCESS', 'âœ… Bot connected to WhatsApp successfully!');
            console.log(`ğŸ¤– Bot JID: ${sock.user?.id}`);
            console.log(`ğŸ“± Bot Number: ${sock.user?.id.split(':')[0]}@s.whatsapp.net`);
            console.log('='.repeat(60) + '\n');
        }
        
        if (connection === 'close') {
            const statusCode = lastDisconnect?.error?.output?.statusCode;
            const errorMessage = lastDisconnect?.error?.message || '';
            
            console.log('âŒ Connection closed:', errorMessage || 'Unknown error');
            
            // Check if it's a logout
            if (statusCode === 401 || errorMessage.includes('logged out')) {
                log('ERROR', 'âŒ Bot was logged out. Delete auth folder and restart.');
                console.log('\nğŸ’¡ Run: rm -rf auth/ && npm run dev\n');
                process.exit(1);
            }
            
            // Check for other errors
            if (errorMessage.includes('networking')) {
                log('WARN', 'ğŸŒ Network error, reconnecting in 10 seconds...');
                setTimeout(startBot, 10000);
            } else {
                log('WARN', 'ğŸ”„ Connection closed, reconnecting in 5 seconds...');
                setTimeout(startBot, 5000);
            }
        }
    });

    // Save credentials
    sock.ev.on('creds.update', saveCreds);

    // Handle messages
    sock.ev.on('messages.upsert', async ({ messages, type }) => {
        // Only process new messages
        if (type !== 'notify') return;
        
        const msg = messages[0];
        if (!msg.message) return;
        
        const from = msg.key.remoteJid;
        const sender = msg.key.participant || from;
        const isGroup = from.endsWith('@g.us');
        const text = msg.message.conversation || 
                     msg.message.extendedTextMessage?.text || 
                     msg.message.imageMessage?.caption || 
                     '';

        if (!text) return;

        // Log message
        console.log(`ğŸ“¨ ${isGroup ? '[GROUP]' : '[DM]'} ${sender.split('@')[0]}: ${text.substring(0, 50)}`);

        // Find or create user
        let user = await User.findOne({ jid: sender });
        if (!user) {
            user = new User({
                jid: sender,
                number: sender.split('@')[0],
                name: msg.pushName || 'Unknown'
            });
            await user.save();
            log('INFO', `ğŸ‘¤ New user registered: ${user.number}`);
        }

        // Update user stats
        user.lastActive = Date.now();
        user.usageCount += 1;
        await user.save();

        // Handle commands
        if (text.startsWith(process.env.PREFIX)) {
            const args = text.slice(1).trim().split(/ +/);
            const command = args.shift().toLowerCase();
            
            log('INFO', `âš¡ Command: ${command} from ${user.number}`);

            switch(command) {
                case 'ping':
                    const start = Date.now();
                    await sock.sendMessage(from, { text: 'ğŸ“ Pong!' });
                    const end = Date.now();
                    await sock.sendMessage(from, { text: `â±ï¸ Response: ${end - start}ms` });
                    break;

                case 'menu':
                    const menuText = `â•­â”€â”€ ğŸ¤– *TRAGICAL BOT* â”€â”€â•®
â”‚ ğŸ“± Status: ${user.paired ? 'âœ… Paired' : 'âŒ Unpaired'}
â”‚ ğŸ‘‘ Role: ${user.role}
â”‚
â”‚ ğŸ“‹ *Available Commands:*
â”‚
â”‚ ğŸ”° *Public Commands*
â”‚ /menu - Show this menu
â”‚ /info - Your information
â”‚ /play <song> - Search music
â”‚ /pair - Get pairing code
â”‚ /ping - Check bot response
â”‚
â”‚ ğŸ”’ *Paired Commands*
â”‚ (Coming soon)
â”‚
â”‚ ğŸ‘‘ *Owner Commands*
â”‚ (Coming soon)
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

ğŸŒ *Official Group:* (Coming soon)`;
                    
                    await sock.sendMessage(from, { text: menuText });
                    break;

                case 'info':
                    const infoText = `ğŸ“Š *YOUR INFORMATION*
                    
ğŸ‘¤ *Name:* ${user.name}
ğŸ“± *Number:* ${user.number}
ğŸ”— *Paired:* ${user.paired ? 'âœ… Yes' : 'âŒ No'}
ğŸ‘‘ *Role:* ${user.role}
ğŸ“Š *Commands Used:* ${user.usageCount}
â° *Last Active:* ${new Date(user.lastActive).toLocaleString()}
ğŸ“… *Joined:* ${new Date(user.createdAt).toLocaleDateString()}`;
                    
                    await sock.sendMessage(from, { text: infoText });
                    break;

                case 'play':
                    if (!args.length) {
                        await sock.sendMessage(from, { text: 'âŒ Usage: /play <song name>' });
                        return;
                    }
                    const query = args.join(' ');
                    await sock.sendMessage(from, { text: `ğŸ” Searching for: "${query}"...` });
                    // We'll implement this later
                    break;

                case 'pair':
                    if (user.paired) {
                        await sock.sendMessage(from, { text: 'âœ… You are already paired!' });
                        return;
                    }
                    await sock.sendMessage(from, { text: 'ğŸ” Pairing system coming soon!' });
                    break;

                default:
                    await sock.sendMessage(from, { text: 'â“ Unknown command. Try /menu' });
            }
        }
    });

    return sock;
}

// Start the bot with error handling
startBot().catch(error => {
    log('ERROR', `ğŸ’¥ Fatal error: ${error.message}`);
    console.error(error);
    process.exit(1);
});
